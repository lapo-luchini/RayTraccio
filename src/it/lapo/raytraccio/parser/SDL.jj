options {
    STATIC = false;
}

PARSER_BEGIN(SDL)

// RayTraccio ray-tracing library Copyright (c) 2001-2022 Lapo Luchini <lapo@lapo.it>

package it.lapo.raytraccio.parser;

import java.util.Hashtable;

import it.lapo.raytraccio.*;
import it.lapo.raytraccio.pattern.*;
import it.lapo.raytraccio.shape.*;
import it.lapo.raytraccio.texture.*;

/**
 * Scene Definition Language parser
 * <br>Generated by <a href="https://javacc.dev.java.net/">JavaCC</a>
 */
public class SDL {

	public Hashtable<String, Object> cons = new Hashtable<String, Object>();

	public static void main(String args[]) throws ParseException {
		SDL parser = new SDL(System.in);
		parser.sdlScene();
		System.out.println("Succesfully parsed.");
	}

}

PARSER_END(SDL)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : // numeric constants
{
	< PERCENT_CONSTANT: <NUMERIC_CONSTANT> "%" >
|	< NUMERIC_CONSTANT: <FLOAT> ( ["e","E"] (["-","+"])? <INTEGER> )? >
|	< #FLOAT: <INTEGER> ( "." <INTEGER> )? | "." <INTEGER> >
|	< #INTEGER: ( <DIGIT> )+ >
|	< #DIGIT: ["0"-"9"] >
}

TOKEN : // user-creable constants
{
	< SHAPE_CONSTANT:   ["S"] <ALPHA> ( <ALPHANUMERIC> )* >
|	< TEXTURE_CONSTANT: ["T"] <ALPHA> ( <ALPHANUMERIC> )* >
|	< PATTERN_CONSTANT: ["P"] <ALPHA> ( <ALPHANUMERIC> )* >
|	< VALUE_CONSTANT:   ["V"] <ALPHA> ( <ALPHANUMERIC> )* >
|	< #ALPHANUMERIC: <ALPHA> | <DIGIT> >
|	< #ALPHA: ["a"-"z","A"-"Z","_"] >
}

Scene sdlScene() :
{
	Shape3D a;
	Vector3D ex=new Vector3D(0.0, 1.0,-5.0);
	Vector3D ox=new Vector3D(0.0,-0.5, 0.0);
	Vector3D hx=new Vector3D(4.0, 0.0, 0.0);
	double ratio=1.0;
	Light l;
	Scene u;
}
{
	[
		"scene" "{" (
			"camera" ex=sdlVector()
		|	"target" ox=sdlVector()
		|	"horizon" hx=sdlVector()
		|	"ratio" ratio=sdlNumber()
		)* "}"
	]
	(
		LOOKAHEAD(2)
		sdlAssignement()
	)*
	a=sdlShape() // yeah, only one shape!
	{ u=new Scene(a, ex, ox, hx, ratio); }
	( l=sdlLight() { u.addLight(l); } )* // yeah, many lights!
	<EOF>
	{ return(u); }
}

Object sdlAssignement() :
{
	Token t;
	Object a;
}
{
	(
		a=sdlAssignementShape()
	|	a=sdlAssignementPattern()
	|	a=sdlAssignementTexture()
	|	a=sdlAssignementValue()
	)
	{ return(a); }
}

Shape3D sdlAssignementShape() :
{
	Token t;
	Shape3D a;
}
{
	t=<SHAPE_CONSTANT> "=" a=sdlShape()
	{
		if(cons.containsKey(t.image))
			throw new ParseException("Shape constant '"+t.image+"' is already assigned (line "+t.beginLine+", column "+t.beginColumn+").");
		cons.put(t.image, a);
		return(a);
	}
}

Pattern sdlAssignementPattern() :
{
	Token t;
	Pattern a;
}
{
	t=<PATTERN_CONSTANT> "=" a=sdlPattern()
	{
		if(cons.containsKey(t.image))
			throw new ParseException("Pattern constant '"+t.image+"' is already assigned (line "+t.beginLine+", column "+t.beginColumn+").");
		cons.put(t.image, a);
		return(a);
	}
}

Texture sdlAssignementTexture() :
{
	Token t;
	Texture a;
}
{
	t=<TEXTURE_CONSTANT> "=" a=sdlTexture()
	{
		if(cons.containsKey(t.image))
			throw new ParseException("Texture constant '"+t.image+"' is already assigned (line "+t.beginLine+", column "+t.beginColumn+").");
		cons.put(t.image, a);
		return(a);
	}
}

Double sdlAssignementValue() :
{
	Token t;
	double a;
}
{
	t=<VALUE_CONSTANT> "=" a=sdlNumber()
	{
		if(cons.containsKey(t.image))
			throw new ParseException("Value constant '"+t.image+"' is already assigned (line "+t.beginLine+", column "+t.beginColumn+").");
		Double oa=new Double(a);
		cons.put(t.image, oa);
		return(oa);
	}
}

Shape3D sdlShape() :
{
	Token t;
	Vector3D v;
	Shape3D u;
	boolean c=false; // c is set to true for shapes that must be transformed only through ShapeTransform
	Texture tx;
}
{
	(
		u=sdlPlane()
	|	u=sdlQuadric()
	|	u=sdlCSG() { c=true; }
	|	u=sdlShapePoly() { c=true; }
	|	u=sdlBound() { c=true; }
	|	LOOKAHEAD(2) u=sdlAssignementShape() "{" { c=true; }
	|	t=<SHAPE_CONSTANT> "{" {
			u=(Shape3D)cons.get(t.image);
			if(u==null)
				throw new ParseException("Shape constant '"+t.image+"' was not assigned (line "+t.beginLine+", column "+t.beginColumn+").");
			c=true;  // set the shape as "to be referenced"
		}
	)
		(
			"rotate" v=sdlVector()    { if(c || !(u instanceof ShapeTransform)) { u=new ShapeTransform(u); c=false; } u.rotate(v); }
		|	"scale" v=sdlVector()     { if(c) { u=new ShapeTransform(u); c=false; } u.scale(v); }
		|	"translate" v=sdlVector() { if(c) { u=new ShapeTransform(u); c=false; } u.translate(v); }
		|	"overturn"                { if(c) { u=new ShapeTransform(u); c=false; } u.overturn(); }
		|	"texture" tx=sdlTexture() { if(c) { u=new ShapeTransform(u); } u.texture(tx); c=true; }
		)*
	"}"
	{ return(u); }
}

Light sdlLight() :
{
	Vector3D o;
	Color c;
	double p;
}
{
	"light" "{"
		["position"] o=sdlVector() // posizione
		["color"] c=sdlColor() // colore
		["distance"] p=sdlNumber() // potenza
	"}"
	{ return(new Light(o, c, p)); }
}

CSG_Collection sdlCSG() :
{
	Shape3D t;
	CSG_Collection u;
}
{
	(
		"union" { u=new CSG_Union(); }
	|	"intersection" { u=new CSG_Intersection(); }
	|	"difference" { u=new CSG_Difference(); }
	) "{"
		( t=sdlShape() { u.add(t); } )+
	{
		u.optimize();
		return(u);
	}
}

Plane sdlPlane() :
{
	Vector3D o;
	double d;
}
{
	"plane" "{"
		o=sdlVector() d=sdlNumber()
	{ return(new Plane(o, d, Plain.WHITE)); }
}

Quadric sdlQuadric() :
{
	double a[];
}
{
	"quadric" "{"
		(
			a=sdlArray(10)
		|	"sphere" { a=Quadric.SFERA; }
		|	"cylinder" { a=Quadric.CIL_Y; }
		|	"cone" { a=Quadric.CONO_Y; }
		|	"paraboloid" { a=Quadric.PARA_Y; }
		|	"hyperboloid" { a=Quadric.IPE_Y; }
		)
	{ return(new Quadric(a, Plain.WHITE)); }
}

ShapePoly sdlShapePoly() :
{
	ShapePoly u=new ShapePoly(Plain.WHITE);
	double v, tmp;
	byte x, y, z;
	boolean pos;
}
{
	"poly" "{" (
		{ v=1.0; x=y=z=0; }
		(
			"+" { pos=true; }
		|	"-" { pos=false; }
		)
		(
			tmp=sdlNumericAddend() { v*=tmp; }
		|	"x" tmp=sdlNumericConstant() { x+=(byte)tmp; }
		|	"y" tmp=sdlNumericConstant() { y+=(byte)tmp; }
		|	"z" tmp=sdlNumericConstant() { z+=(byte)tmp; }
		)
		(
			(
				"x" tmp=sdlNumericConstant() { x+=(byte)tmp; }
			|	"y" tmp=sdlNumericConstant() { y+=(byte)tmp; }
			|	"z" tmp=sdlNumericConstant() { z+=(byte)tmp; }
			)
		)*
		{ u.add((pos ? v : -v), x, y, z); }
	)+
	{ return(u); }
}

Bound sdlBound() :
{
	Shape3D a, b;
}
{
	"bound" "{"
		a=sdlShape() b=sdlShape()
	{ return(new Bound(a, b)); }
}

Texture sdlTexture() :
{
	Texture u;
	Token t;
	TransformMatrix m=TransformMatrix.IDENTITY;
	Vector3D v;
	double a[];
}
{
	(
		u=sdlPlain()
	|	u=sdlTextureMix()
	|	u=sdlTextureLinear()
	|	u=sdlTextureMap()
	|	u=sdlTextureLayered()
	|	LOOKAHEAD(2) u=sdlAssignementTexture() "{"
	|	t=<TEXTURE_CONSTANT> "{" {
			u=(Texture)cons.get(t.image);
			if(u==null)
				throw new ParseException("Texture constant '"+t.image+"' was not assigned (line "+t.beginLine+", column "+t.beginColumn+").");
		}
	)
	(
		"tranform" a=sdlArray(12) { m=m.mul(new TransformMatrix(a)); }
	|	"rotate" v=sdlVector() { m=m.mul(TransformMatrix.RotateXYZ(v.x, v.y, v.z)); }
	|	"scale" v=sdlVector() { m=m.mul(TransformMatrix.Scale(v.x, v.y, v.z)); }
	|	"translate" v=sdlVector() { m=m.mul(TransformMatrix.Translate(v.x, v.y, v.z)); }
	)*
	"}"
	{
		if(m!=TransformMatrix.IDENTITY) //TODO cambiarlo con un test pi√π serio
			u=new Transform(u, m);
		return(u);
	}
}

Plain sdlPlain() :
{
	Color c;
	double r=0.0;
}
{
	"plain" "{"
		"color" c=sdlColor()
		[ "reflect " r=sdlNumber() ]
	{ return(new Plain(c, r)); }
}

Mix sdlTextureMix() :
{
	Texture a, b;
	double da, db;
}
{
	"mix" "{"
		da=sdlNumber() a=sdlTexture()
		db=sdlNumber() b=sdlTexture()
	{ return(new Mix(a, da, b, db)); }
}

Linear sdlTextureLinear() :
{
	Texture a, b;
	Pattern p;
}
{
	"linear" "{"
		p=sdlPattern()
		a=sdlTexture()
		b=sdlTexture()
	{ return(new Linear(a, b, p)); }
}

Map sdlTextureMap() :
{
    Map u;
	Pattern p;
	double a, ao=0.0;
	Texture b;
}
{
	"map" "{"
		p=sdlPattern() { u=new Map(p); }
		(
			a=sdlNumber() {
				if(a<ao)
					throw new ParseException("Values of a TextureMap must be >= of the previous value ("+ao+")");
				if(a>1.0)
					throw new ParseException("Values of a TextureMap must be in the [0.0-1.0] range");
				ao=a;
			}
			b=sdlTexture()
			{ u.add(a, b); }
		)+
	{
		u.optimize();
		return(u);
	}
}

Layered sdlTextureLayered() :
{
	Layered u=new Layered();
	Texture a;
}
{
	"layered" "{"
		( a=sdlTexture() { u.add(a); } )+
	{
		u.optimize();
		return(u);
	}
}

Color sdlColor() :
{
	double[] a=new double[4];
	int n;
}
{(
	"<" a[0]=sdlNumber() (
		">" { n=1; }
	|	"," a[1]=sdlNumber() "," a[2]=sdlNumber() (
			">" { n=3; }
		|	"," a[3]=sdlNumber() ">" { n=4; }
		)
	) {
		for(int i=0; i<n; i++)
			if(a[i]<0.0)
				throw new ParseException("Components of a color must be positive (component"+i+"="+a[i]+" on line "+getNextToken().beginLine+")");
		switch(n) {
			case 1: return(new Color(a[0], a[0], a[0]));
			case 3: return(new Color(a[0], a[1], a[2]));
			case 4: return(new Color(a[0], a[1], a[2], a[3]));
		}
	}
|	"black"  { return(Color.BLACK); }
|	"red"    { return(Color.RED); }
|	"green"  { return(Color.GREEN); }
|	"blue"   { return(Color.BLUE); }
|	"yellow" { return(Color.YELLOW); }
|	"cyan"   { return(Color.CYAN); }
|	"purple" { return(Color.PURPLE); }
|	"white"  { return(Color.WHITE); }
)}

Pattern sdlPattern() :
{
	Pattern p;
	Token t;
}
{(
	p=sdlPatternPerlin()
|	p=sdlPatternPerlinAbs()
|	p=sdlPatternMarble()
|	p=sdlPatternChecker()
|	p=sdlPatternStripes()
|	p=sdlPatternSawtooth()
|	p=sdlPatternInverse()
|	p=sdlPatternTriangle()
|	p=sdlPatternSine()
|	p=sdlPatternTurbulence()
|	LOOKAHEAD(2) p=sdlAssignementPattern()
|	t=<PATTERN_CONSTANT> {
		p=(Pattern)cons.get(t.image);
		if(p==null)
			throw new ParseException("Pattern constant '"+t.image+"' was not assigned (line "+t.beginLine+", column "+t.beginColumn+").");
	}
) { return(p); }
}

Perlin sdlPatternPerlin() :
{
	Token t;
	byte o;
	double p;
	long s;
}
{
	"noise" "{"
		["octaves"] t=<NUMERIC_CONSTANT> { o=(new Byte(t.image)).byteValue(); }
		["persistence"] p=sdlNumber()
		["seed"] t=<NUMERIC_CONSTANT> { s=(new Long(t.image)).longValue(); }
	"}"
	{ return new Perlin(o, p, s); }
}

PerlinAbs sdlPatternPerlinAbs() :
{
	Token t;
	byte o;
	double p;
	long s;
}
{
	"noise_abs" "{"
		["octaves"] t=<NUMERIC_CONSTANT> { o=(new Byte(t.image)).byteValue(); }
		["persistence"] p=sdlNumber()
		["seed"] t=<NUMERIC_CONSTANT> { s=(new Long(t.image)).longValue(); }
	"}"
	{ return new PerlinAbs(o, p, s); }
}

Marble sdlPatternMarble() :
{
	Pattern n;
	double p;
}
{
	"marble" "{"
		n=sdlPattern()
		["turbulence"] p=sdlNumber()
	"}"
	{ return new Marble(n, p); }
}

Checker sdlPatternChecker() :
{
}
{
	"checker" "{" "}"
	{ return new Checker(); }
}

Stripes sdlPatternStripes() :
{
}
{
	"stripes" "{" "}"
	{ return new Stripes(); }
}

Sawtooth sdlPatternSawtooth() :
{
}
{
	"sawtooth" "{" "}"
	{ return new Sawtooth(); }
}

Inverse sdlPatternInverse() :
{
	Pattern p;
}
{
	"inverse" "{"
		p=sdlPattern()
	"}"
	{ return new Inverse(p); }
}

Triangle sdlPatternTriangle() :
{
	Pattern p;
}
{
	"triangle" "{"
		p=sdlPattern()
	"}"
	{ return new Triangle(p); }
}

HalfSine sdlPatternHalfSine() :
{
	Pattern p;
}
{
	"sine" "{"
		p=sdlPattern()
	"}"
	{ return new HalfSine(p); }
}

Sine sdlPatternSine() :
{
	Pattern p;
}
{
	"sine" "{"
		p=sdlPattern()
	"}"
	{ return new Sine(p); }
}

Turbulence sdlPatternTurbulence() :
{
	Pattern p, n;
	Vector3D t;
}
{
	"turbulence" "{"
		p=sdlPattern()
		n=sdlPattern()
		["turbulence"] t=sdlVector()
	"}"
	{ return new Turbulence(p, n, t); }
}

double[] sdlArray(int dim) :
{
	double u[]=new double[dim];
	int n=1;
}
{
	"[" u[0]=sdlNumber() ( "," {
		if(n>=dim)
			throw new ParseException("Found more than "+dim+" fields in an array on line "+getNextToken().beginLine);
	} u[n++]=sdlNumber() )* "]" {
		if(n!=dim) throw new ParseException("Found less than "+dim+" fields in an array on line "+getNextToken().beginLine);
		return u;
	}
}

Vector3D sdlVector() :
{
	Vector3D a, b;
}
{
	a=sdlVectorialAddend()
	(
		"+v" b=sdlVectorialAddend() { a.addU(b); }
	|	"-v" b=sdlVectorialAddend() { a.subU(b); }
	)*
	{ return a; }
}

Vector3D sdlVectorialAddend() :
{
	Vector3D a, b;
}
{
	a=sdlVectorialFactor()
	(
		"x" b=sdlVectorialFactor() { a=a.cross(b); }
	)*
	{ return a; }
}

Vector3D sdlVectorialFactor() :
{
	double[] a=new double[3];
}
{
	"<" a[0]=sdlNumber() (
		">" { return(new Vector3D(a[0], a[0], a[0])); }
	|	"," a[1]=sdlNumber() "," a[2]=sdlNumber() ">" { return new Vector3D(a[0], a[1], a[2]); }
	)
}

double sdlNumber() :
{
	double a, b;
}
{
	(
		[ "+" ] a=sdlNumericAddend()
	|	  "-"   a=sdlNumericAddend() { a=-a; }
	)
	(
		  "+"   b=sdlNumericAddend() { a+=b; }
	|	  "-"   b=sdlNumericAddend() { a-=b; }
	)*
	{ return a; }
}

double sdlNumericAddend() :
{
	double a, b;
}
{
	a=sdlNumericFactor()
	(
		"*" b=sdlNumericFactor() { a*=b; }
	|	"/" b=sdlNumericFactor() { a/=b; }
	)*
	{ return a; }
}

double sdlNumericFactor() :
{
	Vector3D a, b;
	double d;
}
{
	(
		d=sdlNumericConstant()
	|	"(" (
			d=sdlNumber()
		|	a=sdlVector() "." b=sdlVector() { d=a.dot(b); }
		) ")"
	)
	{ return d; }
}

double sdlNumericConstant() :
{
	Token t;
}
{	// I'd rather use Double.parseValue() but it isn't supported in browsers
	t=<NUMERIC_CONSTANT> { return Double.parseDouble(t.image); }
|	t=<PERCENT_CONSTANT> { return 0.01 * Double.parseDouble(t.image.substring(0, t.image.length()-1)); }
|	"pi" { return(Math.PI); }
|	"e" { return(Math.E); }
|	t=<VALUE_CONSTANT> {
		Double u=(Double)cons.get(t.image);
		if(u==null)
			throw new ParseException("Value constant '"+t.image+"' was not assigned (line "+t.beginLine+", column "+t.beginColumn+").");
		return u.doubleValue();
	}
}